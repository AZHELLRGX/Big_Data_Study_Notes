# HADOOP

## HA高可用

（1）HA（High Availablity），即高可用。

（2）实现高可用最关键的策略是消除单点故障。HA严格来说应该分成各个组件的HA机制：HDFS的HA和YARN的HA。

下面主要讲解HDFS的高可用，关于Yarn的高可用可以参考： [YARN-RM的高可用（High Availability](https://www.zybuluo.com/changedi/note/675439) 

 主要还是针对Hadoop2.0的高可用场景，关于Hadoop3.0的特性可以参考[hadoop3.0新特性总结](https://zhuanlan.zhihu.com/p/338504820) 

### 高可用原理

#### NFS【Network FileSystem】

 ![img](%E9%AB%98%E5%8F%AF%E7%94%A8.assets/20190321095954334.png) 

NFS作为Active NameNode和Standby NameNode之间数据共享的存储。Active NameNode会把最近的edits文件写到NFS，而Standby NameNode从NFS中把数据读过来。这个方式的缺点是，如果Active NameNode或者Standby Namenode有一个和NFS之间网络有问题，则会造成他们之前数据的同步出问题。

 #### QJM（Quorum Journal Manager ） 

 ![img](%E9%AB%98%E5%8F%AF%E7%94%A8.assets/20190321094214552.png) 

QJM的方式可以解决上述NFS容错机制不足的问题。Active NameNode和Standby NameNode之间是通过一组JournalNode（数量是奇数，可以是3,5,7…,2n+1）来共享数据。Active NameNode把最近的edits文件写到**2n+1**个JournalNode上，只要有n+1个写入成功就认为这次写入操作成功了，然后Standby NameNode就可以从JournalNode上读取了。可以看到，QJM方式有容错机制，可以容忍n个JournalNode的失败。

#### NN之间数据交互

Active和Standby两个NameNode之间的数据交互流程为：

- NameNode在启动后，会先加载FSImage文件和共享目录上的EditLog Segment文件；
- Standby NameNode会启动EditLogTailer线程和StandbyCheckpointer线程，正式进入Standby模式；、
- Active NameNode把EditLog提交到JournalNode集群；
- Standby NameNode上的EditLogTailer 线程定时从JournalNode集群上同步EditLog；
- Standby NameNode上的StandbyCheckpointer线程定时进行Checkpoint，并将Checkpoint之后的FSImage文件上传到Active NameNode。（在HA模式中中不再有Secondary NameNode这个角色了，StandbyCheckpointer线程的作用其实是为了替代单NN节点的Hadoop架构中的Secondary NameNode的功能。）

QJM方式有明显的优点，一是本身就有fencing的功能，二是通过多个Journal节点增强了系统的健壮性，所以建议在生产环境中采用QJM的方式。JournalNode消耗的资源很少，不需要额外的机器专门来启动JournalNode，可以从Hadoop集群中选几台机器同时作为JournalNode。

 ![img](%E9%AB%98%E5%8F%AF%E7%94%A8.assets/18084125_Syti.png) 

### 故障转移机制

自动故障转移需要配置ZK

 ![img](%E9%AB%98%E5%8F%AF%E7%94%A8.assets/20200729235604908.png) 